diff --git a/Lib/posixpath.py b/Lib/posixpath.py
index bbc2369ce7..bd592d06a2 100644
--- a/Lib/posixpath.py
+++ b/Lib/posixpath.py
@@ -51,7 +51,7 @@ def normcase(s):
 
 def isabs(s):
     """Test whether a path is absolute"""
-    return s.startswith('/')
+    return s.startswith('/') or s.startswith('sdmc:') or s.startswith('romfs:') or s.startswith('nxlink:')
 
 
 # Join pathnames.
@@ -65,7 +65,7 @@ def join(a, *p):
     ends with a separator."""
     path = a
     for b in p:
-        if b.startswith('/'):
+        if b.startswith('/') or b.startswith('sdmc:') or b.startswith('romfs:') or b.startswith('nxlink:'):
             path = b
         elif path == '' or path.endswith('/'):
             path +=  b
@@ -277,7 +277,7 @@ def expanduser(path):
             return path
         userhome = pwent.pw_dir
     userhome = userhome.rstrip('/')
-    return (userhome + path[i:]) or '/'
+    return (userhome + path[i:]) or 'sdmc:/'
 
 
 # Expand paths containing shell variable substitutions.
@@ -340,11 +340,6 @@ def normpath(path):
     if path == '':
         return dot
     initial_slashes = path.startswith('/')
-    # POSIX allows one or two initial slashes, but treats three or more
-    # as single slash.
-    if (initial_slashes and
-        path.startswith('//') and not path.startswith('///')):
-        initial_slashes = 2
     comps = path.split('/')
     new_comps = []
     for comp in comps:
@@ -358,7 +353,7 @@ def normpath(path):
     comps = new_comps
     path = slash.join(comps)
     if initial_slashes:
-        path = slash*initial_slashes + path
+        path = 'sdmc:/' + path
     return path or dot
 
 
@@ -386,8 +381,18 @@ symbolic links encountered in the path."""
 # encountered in the second path.
 def _joinrealpath(path, rest, seen):
     if isabs(rest):
-        rest = rest[1:]
-        path = sep
+        if rest.startswith('sdmc:/'):
+            rest = rest[6:]
+            path = 'sdmc:/'
+        elif rest.startswith('romfs:/'):
+            rest = rest[7:]
+            path = 'romfs:/'
+        elif rest.startswith('nxlink:/'):
+            rest = rest[8:]
+            path = 'nxlink:/'
+        else:
+            rest = rest[1:]
+            path = sep
 
     while rest:
         name, _, rest = rest.partition(sep)
diff --git a/Modules/Setup.dist b/Modules/Setup.dist
index bbc9222129..43f3ff45e7 100644
--- a/Modules/Setup.dist
+++ b/Modules/Setup.dist
@@ -114,7 +114,7 @@ PYTHONPATH=$(COREPYTHONPATH)
 
 posix posixmodule.c		# posix (UNIX) system calls
 errno errnomodule.c		# posix (UNIX) errno values
-pwd pwdmodule.c			# this is needed to find out the user's home dir
+#pwd pwdmodule.c			# this is needed to find out the user's home dir
 				# if $HOME is not set
 _sre _sre.c			# Fredrik Lundh's new regular expressions
 _codecs _codecsmodule.c		# access to the builtin codecs and codec registry
diff --git a/Modules/posixmodule.c b/Modules/posixmodule.c
index 7a1a6945c1..0c0688976d 100644
--- a/Modules/posixmodule.c
+++ b/Modules/posixmodule.c
@@ -141,6 +141,7 @@ corresponding Unix manual entries for more information on calls.");
 /* Everything needed is defined in PC/os2emx/pyconfig.h or vms/pyconfig.h */
 #else                   /* all other compilers */
 /* Unix functions that the configure script doesn't check for */
+#if !defined(__SWITCH__)
 #define HAVE_EXECV      1
 #define HAVE_FORK       1
 #if defined(__USLC__) && defined(__SCO_VERSION__)       /* SCO UDK Compiler */
@@ -161,6 +162,26 @@ corresponding Unix manual entries for more information on calls.");
 #define HAVE_SYSTEM     1
 #define HAVE_WAIT       1
 #define HAVE_TTYNAME    1
+#else
+#ifdef HAVE_GETGROUPS
+#undef HAVE_GETGROUPS
+#endif
+#ifdef HAVE_SETGROUPS
+#undef HAVE_SETGROUPS
+#endif
+#ifdef HAVE_SYMLINK
+#undef HAVE_SYMLINK
+#endif
+#ifdef HAVE_CHROOT
+#undef HAVE_CHROOT
+#endif
+#ifdef HAVE_FDATASYNC
+#undef HAVE_FDATASYNC
+#endif
+#ifdef HAVE_FCHDIR
+#undef HAVE_FCHDIR
+#endif
+#endif  /* ! __SWITCH__ */
 #endif  /* PYOS_OS2 && PYCC_GCC && __VMS */
 #endif  /* _MSC_VER */
 #endif  /* __BORLANDC__ */
@@ -2854,6 +2875,7 @@ posix_system(PyObject *self, PyObject *args)
 #endif
 
 
+#if defined(HAVE_UMASK)
 PyDoc_STRVAR(posix_umask__doc__,
 "umask(new_mask) -> old_mask\n\n\
 Set the current numeric umask and return the previous umask.");
@@ -2869,6 +2891,7 @@ posix_umask(PyObject *self, PyObject *args)
         return posix_error();
     return PyInt_FromLong((long)i);
 }
+#endif /* defined(HAVE_UMASK) */
 
 
 PyDoc_STRVAR(posix_unlink__doc__,
@@ -8919,7 +8942,9 @@ static PyMethodDef posix_methods[] = {
 #ifdef HAVE_SYSTEM
     {"system",          posix_system, METH_VARARGS, posix_system__doc__},
 #endif
+#ifdef HAVE_UMASK
     {"umask",           posix_umask, METH_VARARGS, posix_umask__doc__},
+#endif
 #ifdef HAVE_UNAME
     {"uname",           posix_uname, METH_NOARGS, posix_uname__doc__},
 #endif /* HAVE_UNAME */
diff --git a/Modules/timemodule.c b/Modules/timemodule.c
index 61b8d612a4..ea18e5a2d6 100644
--- a/Modules/timemodule.c
+++ b/Modules/timemodule.c
@@ -808,7 +808,11 @@ inittimezone(PyObject *m) {
 #ifdef PYOS_OS2
     PyModule_AddIntConstant(m, "timezone", _timezone);
 #else /* !PYOS_OS2 */
+#ifdef __SWITCH__
+    PyModule_AddIntConstant(m, "timezone", 0);
+#else
     PyModule_AddIntConstant(m, "timezone", timezone);
+#endif /* __SWITCH__ */
 #endif /* PYOS_OS2 */
 #ifdef HAVE_ALTZONE
     PyModule_AddIntConstant(m, "altzone", altzone);
@@ -816,12 +820,25 @@ inittimezone(PyObject *m) {
 #ifdef PYOS_OS2
     PyModule_AddIntConstant(m, "altzone", _timezone-3600);
 #else /* !PYOS_OS2 */
+#ifdef __SWITCH__
+    PyModule_AddIntConstant(m, "altzone", 0-3600);
+#else
     PyModule_AddIntConstant(m, "altzone", timezone-3600);
+#endif
 #endif /* PYOS_OS2 */
 #endif
+#ifdef __SWITCH__
+    PyModule_AddIntConstant(m, "daylight", 0);
+#else
     PyModule_AddIntConstant(m, "daylight", daylight);
+#endif
+#ifdef __SWITCH__
+    PyModule_AddObject(m, "tzname",
+                       Py_BuildValue("(zz)", "GMT", "UTC"));
+#else
     PyModule_AddObject(m, "tzname",
                        Py_BuildValue("(zz)", tzname[0], tzname[1]));
+#endif
 #else /* !HAVE_TZNAME || __GLIBC__ || __CYGWIN__*/
 #ifdef HAVE_STRUCT_TM_TM_ZONE
     {
diff --git a/Python/import.c b/Python/import.c
index ccbd949e62..1fa46561c4 100644
--- a/Python/import.c
+++ b/Python/import.c
@@ -1402,6 +1402,13 @@ find_module(char *fullname, char *subname, PyObject *path, char *buf,
         Py_DECREF(meta_path);
     }
 
+    // printf("PATCH: find_module(%s)\n", fullname);
+    if (fullname != NULL && is_builtin(fullname)) {
+      // printf("PATCH: submodule %s is built-in!\n", fullname);
+      strcpy(buf, fullname);
+      return &fd_builtin;
+    }
+
     if (path != NULL && PyString_Check(path)) {
         /* The only type of submodule allowed inside a "frozen"
            package are other frozen modules or packages. */
diff --git a/Python/random.c b/Python/random.c
index 000cb36938..c710ba95ea 100644
--- a/Python/random.c
+++ b/Python/random.c
@@ -6,6 +6,9 @@
 #if defined(HAVE_SYS_RANDOM_H) && (defined(HAVE_GETRANDOM) || defined(HAVE_GETENTROPY))
 #include <sys/random.h>
 #endif
+#ifdef __SWITCH__
+#include <switch/kernel/random.h>
+#endif
 #endif
 
 #ifdef Py_DEBUG
@@ -347,6 +350,9 @@ _PyOS_URandom(void *buffer, Py_ssize_t size)
 
 #ifdef MS_WINDOWS
     return win32_urandom((unsigned char *)buffer, size, 1);
+#elif defined(__SWITCH__)
+    randomGet(buffer, size);
+    return 0;
 #elif defined(PY_GETENTROPY)
     return py_getentropy(buffer, size, 0);
 #else
diff --git a/Python/thread.c b/Python/thread.c
index 3b69f961a4..221e7ebbac 100644
--- a/Python/thread.c
+++ b/Python/thread.c
@@ -112,6 +112,11 @@ static size_t _pythread_stacksize = 0;
 #include "thread_lwp.h"
 #endif
 
+#ifdef __SWITCH__
+#include "thread_nx.h"
+#undef _POSIX_THREADS
+#endif
+
 #ifdef HAVE_PTH
 #include "thread_pth.h"
 #undef _POSIX_THREADS
diff --git a/Python/thread_nx.h b/Python/thread_nx.h
new file mode 100644
index 0000000000..b337f57c3b
--- /dev/null
+++ b/Python/thread_nx.h
@@ -0,0 +1,288 @@
+#include "switch/kernel/mutex.h"
+#include "switch/kernel/svc.h"
+#include "switch/kernel/condvar.h"
+#include "switch/types.h"
+#include "switch/arm/tls.h"
+#include "switch/kernel/thread.h"
+
+#define THREAD_STACK_SIZE 0x4000
+#define THREAD_PRIORITY 0x20
+#define THREAD_CPU_ID -2
+
+
+// copied from nx/source/internal.h
+#define THREADVARS_MAGIC 0x21545624 // !TV$
+
+// This structure is exactly 0x20 bytes, if more is needed modify getThreadVars() below
+typedef struct {
+    // Magic value used to check if the struct is initialized
+    u32 magic;
+
+    // Thread handle, for mutexes
+    Handle handle;
+
+    // Pointer to the current thread (if exists)
+    Thread* thread_ptr;
+
+    // Pointer to this thread's newlib state
+    struct _reent* reent;
+
+    // Pointer to this thread's thread-local segment
+    void* tls_tp; // !! Offset needs to be TLS+0x1F8 for __aarch64_read_tp !!
+} ThreadVars;
+
+static inline ThreadVars* getThreadVars(void) {
+    return (ThreadVars*)((u8*)armGetTls() + 0x1E0);
+}
+// end copy
+
+
+/*
+ * Initialization.
+ */
+static
+void _noop(void)
+{
+    // printf("_noop function called\n");
+}
+
+
+static void
+PyThread__init_thread(void)
+{
+    Thread thread1;
+    threadCreate(&thread1, (void *) _noop, NULL, THREAD_STACK_SIZE, THREAD_PRIORITY, THREAD_CPU_ID);
+    threadStart(&thread1);
+    threadWaitForExit(&thread1);
+    threadClose(&thread1);
+}
+
+/*
+ * Thread support.
+ */
+
+typedef struct {
+    ThreadFunc func;
+    void * arg;
+} _wrapperArgs;
+
+static
+void _wrapperFunc(_wrapperArgs * args) {
+    // printf("_wrapperFunc called -> %p, %p\n", args->func, args->arg);
+    args->func(args->arg);
+}
+
+long
+PyThread_start_new_thread(void (*func)(void *), void *arg)
+{
+    dprintf(("PyThread_start_new_thread called\n"));
+    if (!initialized)
+        PyThread_init_thread();
+
+    _wrapperArgs wargs;
+    wargs.arg = arg;
+    wargs.func = func;
+
+    Thread * t = (Thread *)malloc(sizeof(Thread));
+    int rc = threadCreate(t, (ThreadFunc)_wrapperFunc, &wargs, THREAD_STACK_SIZE, THREAD_PRIORITY, THREAD_CPU_ID);
+    // printf("PyThread thread created -> %d\n", rc);
+    if (rc < 0) return -1;
+    rc = threadStart(t);
+    // printf("PyThread thread started -> %p, %d\n", t, rc);
+
+    return rc < 0 ? -1 : 0;
+}
+
+long
+PyThread_get_thread_ident(void)
+{
+    if (!initialized)
+        PyThread_init_thread();
+    Thread * t = getThreadVars()->thread_ptr;
+    // if (t != NULL) printf("PyThread_get_thread_ident called -> %p\n", t);
+    return (long)t + 1;
+}
+
+void
+PyThread_exit_thread(void)
+{
+    dprintf(("PyThread_exit_thread called\n"));
+    if (!initialized)
+        exit(0);
+    
+    // TODO: fix this
+    // Thread * t = getThreadVars()->thread_ptr;
+    // threadClose(t);
+    // free((void *)t);
+    svcExitThread();
+}
+
+/*
+ * Lock support.
+ */
+
+typedef struct {
+    char locked;
+    CondVar cv;
+    Mutex mutex;
+} _thread_lock;
+
+PyThread_type_lock
+PyThread_allocate_lock(void)
+{
+    dprintf(("PyThread_allocate_lock called\n"));
+    if (!initialized)
+        PyThread_init_thread();
+
+    _thread_lock * lock = (_thread_lock *)malloc(sizeof(_thread_lock));
+    lock->locked = 0;
+
+    mutexInit(&(lock->mutex));
+
+    condvarInit(&(lock->cv));
+
+    dprintf(("PyThread_allocate_lock() -> %p\n", lock));
+    return (PyThread_type_lock) lock;
+}
+
+void
+PyThread_free_lock(PyThread_type_lock lock)
+{
+    _thread_lock * thelock = (_thread_lock *)lock;
+
+
+    dprintf(("PyThread_free_lock(%p) called\n", lock));
+
+    if (!thelock)
+        return;
+    
+    free((void *)thelock);
+}
+
+int
+PyThread_acquire_lock_timed(PyThread_type_lock lock, u64 microseconds,
+                            int intr_flag)
+{
+    int success;
+    int status;
+    _thread_lock * thelock = (_thread_lock *)lock;
+    dprintf(("PyThread_acquire_lock_timed(%p, %lld, %d) called\n", 
+            lock, microseconds, intr_flag));
+
+    if (thelock->locked == 1 && microseconds == 0) {
+        success = 0;
+        dprintf(("PyThread_acquire_lock_timed(%p, %lld, %d) -> %d\n",
+            lock, microseconds, intr_flag, success));
+        return success;
+    }
+
+    mutexLock(&(thelock->mutex));
+    if (thelock->locked == 0) {
+        success = 1;
+    } else if (microseconds == 0) {
+        success = 0;        
+    } else {
+        u64 ns = microseconds * 1000;
+
+        success = 0;
+        while (success == 0) {
+            if (microseconds > 0) {
+                status = condvarWaitTimeout(&(thelock->cv), &(thelock->mutex), ns);
+                if (status == 0xEA01) // on timeout
+                    break;
+            }
+            else {
+                status = condvarWait(&(thelock->cv), &(thelock->mutex));
+            }
+
+            if (intr_flag && status == 0 && thelock->locked) {
+                /* We were woken up, but didn't get the lock.  We probably received
+                 * a signal.  Return PY_LOCK_INTR to allow the caller to handle
+                 * it and retry.  */
+            } else if (!thelock->locked) {
+                success = 1;
+            } else {
+                success = 0;
+            }
+        }
+    }
+
+    if (success == 1) {
+        thelock->locked = 1;
+    }
+    mutexUnlock(&(thelock->mutex));
+
+    dprintf(("PyThread_acquire_lock_timed(%p, %lld, %d) -> %d\n",
+         lock, microseconds, intr_flag, success));
+    return success;
+}
+
+int
+PyThread_acquire_lock(PyThread_type_lock lock, int waitflag)
+{
+    return PyThread_acquire_lock_timed(lock, waitflag ? -1 : 0, 0);
+}
+
+void
+PyThread_release_lock(PyThread_type_lock lock)
+{
+    _thread_lock * thelock = (_thread_lock *)lock;
+    dprintf(("PyThread_release_lock(%p) called\n", lock));
+    // printf("PyThread_release_lock(%p) called\n", lock);
+
+    mutexLock(&(thelock->mutex));
+    dprintf(("PyThread_release_lock(%p) mutex locked\n", lock));
+    thelock->locked = 0;
+    condvarWakeOne(&(thelock->cv));
+    mutexUnlock(&(thelock->mutex));
+}
+
+/* The following are only needed if native TLS support exists */
+// #define Py_HAVE_NATIVE_TLS
+
+#ifdef Py_HAVE_NATIVE_TLS
+int
+PyThread_create_key(void)
+{
+    int result;
+    return result;
+}
+
+void
+PyThread_delete_key(int key)
+{
+
+}
+
+int
+PyThread_set_key_value(int key, void *value)
+{
+    int ok;
+
+    /* A failure in this case returns -1 */
+    if (!ok)
+        return -1;
+    return 0;
+}
+
+void *
+PyThread_get_key_value(int key)
+{
+    void *result;
+
+    return result;
+}
+
+void
+PyThread_delete_key_value(int key)
+{
+
+}
+
+void
+PyThread_ReInitTLS(void)
+{
+
+}
+
+#endif
diff --git a/configure b/configure
index 67300fe2b6..7970bd9a4a 100755
--- a/configure
+++ b/configure
@@ -3287,6 +3287,9 @@ then
 	*-*-cygwin*)
 		ac_sys_system=Cygwin
 		;;
+	aarch64-none-elf*)
+		ac_sys_system=Horizon
+		;;
 	*)
 		# for now, limit cross builds to known configurations
 		MACHDEP="unknown"
@@ -3333,6 +3336,9 @@ if test "$cross_compiling" = yes; then
 	*-*-cygwin*)
 		_host_cpu=
 		;;
+	aarch64-none-elf*)
+		_host_cpu=$host_cpu
+		;;
 	*)
 		# for now, limit cross builds to known configurations
 		MACHDEP="unknown"
